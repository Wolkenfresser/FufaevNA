# Отчет по лабораторной работе 10

# Графы

**Дата:** 2025-12-8
**Семестр:** 3 курс 5 семестр
**Группа:** ПИЖ-б-о-23-2(1)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Фуфаев Никита Александрович

## Цель работы

Изучить основные понятия теории графов и алгоритмы работы с ними. Освоить представления графов в памяти и основные алгоритмы обхода. Получить практические навыки реализации алгоритмов на графах и анализа их сложности.

## Практическая часть

### Выполненные задачи

- [ ] Реализовать различные представления графов (матрица смежности, список смежности).
- [ ] Реализовать алгоритмы обхода графов (BFS, DFS).
- [ ] Реализовать алгоритмы поиска кратчайших путей и компонент связности.
- [ ] Провести сравнительный анализ эффективности разных представлений графов.
- [ ] Решить практические задачи на графах.

### Ключевые фрагменты кода

```PYTHON
# graph_representation.py
class AdjacencyMatrixGraph:
    def __init__(self, n):
        self.n = n
        self.matrix = [[0] * n for _ in range(n)]

    def add_edge(self, u, v):
        self.matrix[u][v] = 1
        self.matrix[v][u] = 1  # неориентированный граф

    # Проверка ребра: O(1)
    def has_edge(self, u, v):
        return self.matrix[u][v] == 1


class AdjacencyListGraph:
    def __init__(self, n):
        self.n = n
        self.graph = [[] for _ in range(n)]

    # Добавление ребра: O(1)
    def add_edge(self, u, v):
        self.graph[u].append(v)
        self.graph[v].append(u)  # неориентированный граф

    # Получение соседей: O(k), где k — число соседей
    def neighbors(self, u):
        return self.graph[u]
```

```PYTHON
# graph_traversal.py
from collections import deque

# BFS: O(V + E)
def bfs(graph, start):
    visited = [False] * graph.n
    queue = deque([start])
    visited[start] = True
    order = []

    while queue:
        u = queue.popleft()
        order.append(u)

        for v in graph.neighbors(u):
            if not visited[v]:
                visited[v] = True
                queue.append(v)

    return order


# DFS (итеративный): O(V + E)
def dfs(graph, start):
    visited = [False] * graph.n
    stack = [start]
    order = []

    while stack:
        u = stack.pop()
        if not visited[u]:
            visited[u] = True
            order.append(u)

            for v in reversed(graph.neighbors(u)):
                if not visited[v]:
                    stack.append(v)

    return order
```
## Ответы на контрольные вопросы

## 1. Разница между матрицей смежности и списком смежности

- **Матрица смежности:** квадратная таблица `N×N`, где `1` означает наличие ребра.  
  - Память: `O(N²)`  
  - Проверка наличия ребра: `O(1)`  
  - Перебор соседей: `O(N)`

- **Список смежности:** для каждой вершины хранится список её соседей.  
  - Память: `O(N + M)`  
  - Проверка ребра: `O(deg(v))`  
  - Перебор соседей: `O(deg(v))`

## 2. Алгоритм BFS

- Обходит граф **в ширину**, используя очередь.  
- Начинает с стартовой вершины и проходит по уровням.  
- Применяется для:
  - поиска кратчайшего пути в невзвешенных графах;  
  - проверки связности;  
  - нахождения компонент связности.

## 3. Отличия DFS от BFS

- **DFS** использует стек (или рекурсию) и уходит "в глубину".  
- Применяется для:
  - проверки графа на ацикличность;  
  - топологической сортировки;  
  - поиска мостов и точек сочленения;  
  - обхода всех путей.

## 4. Принцип работы алгоритма Дейкстры

- Выбирает вершину с минимальной текущей дистанцией.  
- Обновляет расстояния до её соседей.  
- Повторяет, пока все вершины не обработаны.  
- Не работает с отрицательными весами, потому что жадный выбор минимальной вершины перестаёт быть корректным — возможны более выгодные пути позже.

## 5. Топологическая сортировка

- Упорядочивает вершины ориентированного графа так, что все ребра идут слева направо.  
- Применима **только к DAG** (ацикличным ориентированным графам).  
- Пример применения:
  - планирование задач с зависимостями;  
  - порядок компиляции модулей;  
  - построение последовательности этапов в проектах.