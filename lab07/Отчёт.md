# Отчет по лабораторной работе 7

# Кучи (Heaps)

**Дата:** 2025-11-19
**Семестр:** 3 курс 5 семестр
**Группа:** ПИЖ-б-о-23-2(1)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Фуфаев Никита Александрович

### Выполненные задачи
- [ ] Реализовать структуру данных "куча" (min-heap и max-heap) на основе массива.
- [ ] Реализовать основные операции и алгоритм построения кучи из массива.
- [ ] Реализовать алгоритм сортировки кучей (Heapsort).
- [ ] Провести анализ сложности операций.
- [ ] Сравнить производительность сортировки кучей с другими алгоритмами.



### Ключевые фрагменты кода

```PYTHON
# heap.py
"""
Min-Heap (минимальная куча)
Уровень: 3
Операции: insert, extract
Сложность:
- insert: O(log n)
- extract: O(log n)
"""

class MinHeap:
    def __init__(self):
        self.data = []

    # Вставка элемента
    # Сложность: O(log n)
    def insert(self, value):
        self.data.append(value)
        self._sift_up(len(self.data) - 1)

    def _sift_up(self, index):
        while index > 0:
            parent = (index - 1) // 2
            if self.data[index] < self.data[parent]:
                self.data[index], self.data[parent] = self.data[parent], self.data[index]
                index = parent
            else:
                break

    # Извлечение минимума (корня)
    # Сложность: O(log n)
    def extract(self):
        if not self.data:
            return None
        if len(self.data) == 1:
            return self.data.pop()

        root = self.data[0]
        self.data[0] = self.data.pop()
        self._sift_down(0)
        return root

    def _sift_down(self, index):
        size = len(self.data)
        while True:
            left = 2 * index + 1
            right = 2 * index + 2
            smallest = index

            if left < size and self.data[left] < self.data[smallest]:
                smallest = left
            if right < size and self.data[right] < self.data[smallest]:
                smallest = right

            if smallest != index:
                self.data[index], self.data[smallest] = self.data[smallest], self.data[index]
                index = smallest
            else:
                break


if __name__ == "__main__":
    h = MinHeap()
    for x in [5, 3, 8, 1, 4]:
        h.insert(x)
    print("Extracted:", h.extract())
    print("Heap state:", h.data)
```

```PYTHON
# measure.py
"""
Базовые замеры производительности кучи.
Уровень: 3.
"""

import time
import random
from heap import MinHeap


def measure(n=10000):
    h = MinHeap()
    values = [random.randint(0, 100000) for _ in range(n)]

    # Вставка
    start = time.time()
    for v in values:
        h.insert(v)
    print(f"Вставка {n} элементов: {time.time() - start:.6f} sec")

    # Извлечение
    start = time.time()
    for _ in range(n):
        h.extract()
    print(f"Извлечение {n} элементов: {time.time() - start:.6f} sec")


if __name__ == "__main__":
    measure(5000)
```

## Ответы на контрольные вопросы

1. **Сформулируйте основное свойство min-кучи и max-кучи.**  
    - Min-heap — это такое бинарное дерево, в котором значение каждого родителя меньше или равно значениям его потомков. Корень min-кучи содержит минимальный элемент.

    - Max-heap — это бинарное дерево, в котором значение каждого родителя больше или равно значениям его потомков. Корень max-кучи содержит максимальный элемент.

2. **Опишите алгоритм вставки нового элемента в кучу (процедуру sift_up).**  
    Алгоритм вставки в кучу устроен следующим образом:
       1. Новый элемент добавляется в конец массива, представляющего собой полное бинарное дерево.
       2. Выполняется процедура sift_up: элемент сравнивается со своим родителем.
       3. Если нарушается свойство кучи (например, в min-heap элемент меньше родителя), элементы меняются местами.
       4. Процесс продолжается, пока либо элемент не окажется в корне, либо свойство кучи не будет восстановлено.
    Высота бинарного дерева логарифмическая, поэтому операция вставки работает за O(log n).

3. **Какова временная сложность построения кучи из произвольного массива и почему она равна O(n), а не O(n log n)?**  
    Хотя кажется, что нужно выполнить sift_down для каждого элемента массива, и каждая операция может занимать до O(log n), на практике построение кучи выполняется за O(n).
    Это происходит потому, что:
    - половина всех элементов массива — листья, и они не требуют вызова sift_down;
    - четверть — находятся на глубине 1;
    - дальше — всё меньше элементов на больших глубинах.
    Общая сумма всех затрат вычисляется как:
        (n/2)*0 + (n/4)*1 + (n/8)*2 + ... + 1*(log n)
    Эта сумма математически равна O(n). Поэтому алгоритм Флойда (build_heap) работает линейно.

4. **Опишите, как работает алгоритм пирамидальной сортировки (Heapsort).**  
    Алгоритм Heapsort состоит из двух этапов:
    1. Построение max-кучи из исходного массива — выполняется за O(n).
    2. Многократное извлечение максимального элемента:
       - Меняем местами первый (максимальный) элемент и последний.
       - Уменьшаем размер кучи на 1.
       - Вызываем sift_down(0), чтобы восстановить max-heap.
    Этот процесс повторяется, пока не будут обработаны все элементы.
    Итоговая сложность Heapsort — O(n log n).
    Сортировка выполняется in-place, не требуя дополнительной памяти (кроме O(1)).

 5. **Почему кучу часто используют для реализации приоритетной очереди? Какие операции приоритетной очереди она эффективно поддерживает?**
    Кучу используют для реализации приоритетной очереди, потому что она обеспечивает быстрый доступ к элементу с максимальным или минимальным приоритетом. Корень кучи всегда содержит элемент с наивысшим приоритетом.
    Куча эффективно поддерживает следующие операции:
    - insert(x) — вставка нового элемента, работает за O(log n);
    - extract_max() / extract_min() — извлечение элемента с максимальным/минимальным приоритетом, работает за O(log n);
    - peek() — получение элемента с высшим приоритетом без удаления, работает за O(1).
    Благодаря этим свойствам куча является оптимальной структурой данных для реализации приоритетных очередей.