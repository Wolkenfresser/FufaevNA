# Лабораторная работа №6 

# Деревья 

**Дата:** 2025-11-12
**Семестр:** 3 курс 5 семестр
**Группа:** ПИЖ-б-о-23-2(1)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Фуфаев Никита Александрович

## Цель работы
Изучить древовидные структуры данных, их свойства и применение. Освоить основные
 операции с бинарными деревьями поиска (BST). Получить практические навыки реализации BST на
 основе узлов (pointer-based), рекурсивных алгоритмов обхода и анализа их эффективности.
 Исследовать влияние сбалансированности дерева на производительность операций.
## Практическая часть

### Выполненные задачи
- [ ] Задача 1: Реализовать бинарное дерево поиска на основе узлов с основными операциями.
- [ ] Задача 2: Реализовать различные методы обхода дерева (рекурсивные и итеративные).
- [ ] Задача 3: Реализовать дополнительные методы для работы с BST.
- [ ] Задача 4: Провести анализ сложности операций для сбалансированного и вырожденного деревьев.
- [ ] Задача 5: Визуализировать структуру дерева.

### Ключевые фрагменты кода

```PYTHON
# binary_search_tree.py
"""
Бинарное дерево поиска (BST) — минимальный набор для оценки «3».
Реализовано:
- класс TreeNode
- класс BinarySearchTree c методами insert, search, in_order
Сложности: O(log n) в среднем, O(n) в худшем случае (вырожденное дерево).
"""

class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None


class BinarySearchTree:
    def __init__(self):
        self.root = None

    # Вставка
    # Средний случай: O(log n)
    # Худший случай: O(n)
    def insert(self, value):
        if self.root is None:
            self.root = TreeNode(value)
            return
        self._insert(self.root, value)

    def _insert(self, node, value):
        if value < node.value:
            if node.left is None:
                node.left = TreeNode(value)
            else:
                self._insert(node.left, value)
        elif value > node.value:
            if node.right is None:
                node.right = TreeNode(value)
            else:
                self._insert(node.right, value)
        # равные значения не вставляем

    # Поиск
    # Средний случай: O(log n)
    # Худший: O(n)
    def search(self, value):
        return self._search(self.root, value)

    def _search(self, node, value):
        if node is None:
            return False
        if value == node.value:
            return True
        elif value < node.value:
            return self._search(node.left, value)
        else:
            return self._search(node.right, value)

    # Рекурсивный обход (in-order): левый — корень — правый
    # Сложность: O(n)
    def in_order(self):
        result = []
        self._in_order(self.root, result)
        return result

    def _in_order(self, node, result):
        if node is not None:
            self._in_order(node.left, result)
            result.append(node.value)
            self._in_order(node.right, result)


if __name__ == "__main__":
    bst = BinarySearchTree()
    for v in [5, 3, 7, 2, 4, 6, 8]:
        bst.insert(v)
    print("In-order:", bst.in_order())
    print("Search 6:", bst.search(6))
    print("Search 10:", bst.search(10))
```

```PYTHON
#measure.py
"""
Базовые замеры времени поиска в BST
"""

import random
import time
from binary_search_tree import BinarySearchTree


def build_bst(values):
    bst = BinarySearchTree()
    for v in values:
        bst.insert(v)
    return bst


def measure():
    # Сбалансированное дерево — случайный порядок
    values_random = [random.randint(0, 100000) for _ in range(5000)]
    bst_random = build_bst(values_random)

    # Вырожденное дерево — отсортированный массив
    values_sorted = list(range(5000))
    bst_sorted = build_bst(values_sorted)

    # Замер поиска
    to_find = [random.randint(0, 100000) for _ in range(1000)]

    print("Сбалансированное дерево:")
    start = time.time()
    for x in to_find:
        bst_random.search(x)
    print(f"Поиск 1000 элементов: {time.time() - start:.6f} sec")

    print("\nВырожденное дерево:")
    start = time.time()
    for x in to_find:
        bst_sorted.search(x)
    print(f"Поиск 1000 элементов: {time.time() - start:.6f} sec")


if __name__ == "__main__":
    measure()
```

## Ответы на контрольные вопросы

1. **Сформулируйте основное свойство бинарного дерева поиска (BST).**
    Значения левого поддерева меньше значения узла, правого — больше.

2. **Опишите алгоритм вставки нового элемента в BST. Какова сложность этой операции в сбалансированном и вырожденном дереве?**
    Поиск подходящего места путём сравнения: если меньше — идём влево, если больше — вправо.
    Сложность:
    - O(log n) в сбалансированном дереве
    - O(n) в вырожденном

3. **Чем отличается обход дерева в глубину (DFS) от обхода в ширину (BFS)? Назовите виды DFS обходов и их особенности.**
    DFS — глубинный обход: pre-order, in-order, post-order.
    BFS — ширинный обход, использует очередь.

4. **Почему в вырожденном BST (например, когда элементы добавляются в отсортированном порядке) сложность операций поиска и вставки становится O(n)?**
    Потому что оно превращается в линейный список, высота дерева становится n.

5. **Что такое сбалансированное дерево (например, AVL-дерево) и как оно решает проблему вырождения BST?**
    Дерево, поддерживающее высоту около log₂(n), благодаря автоматической балансировке (Как в AVL или КЧ-деревьях).