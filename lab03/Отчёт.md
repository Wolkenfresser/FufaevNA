# Лабораторная работа №03

# Рекурсия

**Дата:** 2025-10-21
**Семестр:** 3 курс 5 семестр
**Группа:** ПИЖ-б-о-23-2(1)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Фуфаев Никита Александрович

## Цель работы
Освоить принцип рекурсии, научиться анализировать рекурсивные алгоритмы и
 понимать механизм работы стека вызовов. Изучить типичные задачи, решаемые рекурсивно, и освоить
 технику мемоизации для оптимизации рекурсивных алгоритмов. Получить практические навыки
 реализации и отладки рекурсивных функций.

## Практическая часть

### Выполненные задачи
- [ ] Задача 1: Реализовать классические рекурсивные алгоритмы.
- [ ] Задача 2: Проанализировать их временную сложность и глубину рекурсии.
- [ ] Задача 3: Реализовать оптимизацию рекурсивных алгоритмов с помощью мемоизации.
- [ ] Задача 4: Сравнить производительность наивной рекурсии и рекурсии с мемоизацией.
- [ ] Задача 5: Решить практические задачи с применением рекурсии.


### Ключевые фрагменты кода

```PYTHON
# recursion.py
"""
Базовые рекурсивные функции.
Уровень: 3.
"""

# Факториал n!
# Сложность: O(n), глубина рекурсии = n

def factorial(n: int) -> int:
    if n == 0 or n == 1:
        return 1
    return n * factorial(n - 1)


# Наивное вычисление n-го числа Фибоначчи
# Сложность: O(2^n), глубина рекурсии = n

def fibonacci(n: int) -> int:
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)


# Быстрое возведение в степень (рекурсия деления степени пополам)
# Сложность: O(log n), глубина рекурсии = log n

def fast_pow(a: int, n: int) -> int:
    if n == 0:
        return 1
    if n % 2 == 0:
        half = fast_pow(a, n // 2)
        return half * half
    else:
        return a * fast_pow(a, n - 1)


if __name__ == "__main__":
    print("factorial(5) =", factorial(5))
    print("fibonacci(10) =", fibonacci(10))
    print("fast_pow(2, 10) =", fast_pow(2, 10))
```

```PYTHON
# measure.py
"""
Замеры времени для наивной рекурсивной функции Фибоначчи.
"""

import time
from recursion import fibonacci


def measure(n: int):
    start = time.time()
    result = fibonacci(n)
    end = time.time()
    print(f"n={n}")
    print("result =", result)
    print(f"time = {end - start:.6f} sec")


if __name__ == "__main__":
    for n in [20, 25, 30, 35]:
        measure(n)
```

## Ответы на контрольные вопросы
1. **Что такое базовый случай и рекурсивный шаг в рекурсивной функции? Почему отсутствие базового случая приводит к ошибке?** - Базовый случай определяет условие, при котором рекурсия завершится, а рекурсивный шаг — это правило, по которому функция вызывает сама себя с уменьшенным или изменённым аргументом. Отсутствие базового случая приводит к бесконечной рекурсии и ошибке переполнения стека.

2. **Объясните, как работает механизм мемоизации. Как он меняет временную сложность вычисления чисел Фибоначчи по сравнению с наивной рекурсией?** - Мемоизация сохраняет ранее вычисленные значения в кэше, чтобы повторно их не вычислять. Для чисел Фибоначчи это снижает временную сложность с O(2^n) до O(n).

3. **В чем заключается основная проблема глубокой рекурсии и как она связана со стеком вызовов?** - Основная проблема глубокой рекурсии заключается в возможном переполнении стека вызовов (stack overflow). Каждый рекурсивный вызов сохраняет локальные переменные и адрес возврата в стеке, при глубокой рекурсии стек может исчерпать память.

4. **Задача о Ханойских башнях решается рекурсивно. Опишите алгоритм решения для 3 дисков.** - Перемещаем два верхних диска на вспомогательную башню, затем перемещаем самый большой диск на целевую башню, после чего два верхних диска с вспомогательной башни перемещаем на целевую башню.

5. **Рекурсивный и итеративный алгоритмы могут решать одни и те же задачи. Назовите преимущества и недостатки каждого подхода.** - Рекурсивный: преимущества — лаконичный и наглядный код; недостатки — большая нагрузка на стек, медленнее при больших данных. Итеративный: преимущества — экономичнее по памяти и быстрее; недостатки — код может быть более сложным и менее читаемым.