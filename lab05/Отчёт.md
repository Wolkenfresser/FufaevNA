# Лабораторная работа №5

# Хеш‑функции и хеш‑таблицы

**Дата:** 2025-11-5
**Семестр:** 3 курс 5 семестр
**Группа:** ПИЖ-б-о-23-2(1)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Фуфаев Никита Александрович

## Цель работы
Изучить принципы работы хеш-функций и хеш-таблиц. Освоить методы разрешения
 коллизий. Получить практические навыки реализации хеш-таблицы с различными стратегиями
 разрешения коллизий. Провести сравнительный анализ эффективности разных методов.
## Практическая часть

### Выполненные задачи
- [ ] Задача 1: Реализовать несколько хеш-функций для строковых ключей.
- [ ] Задача 2: Реализовать хеш-таблицу с методом цепочек.
- [ ] Задача 3: Реализовать хеш-таблицу с открытой адресацией (линейное пробирование и двойное
 хеширование).
- [ ] Задача 4: Провести сравнительный анализ эффективности разных методов разрешения коллизий.
- [ ] Задача 5: Исследовать влияние коэффициента заполнения на производительность.



### Ключевые фрагменты кода

```PYTHON
# hash_functions.py
"""
Простая хеш‑функция для строковых ключей.
Уровень: 3.
"""

# Хеш‑функция: сумма кодов символов
# Особенности: простая, быстрая, но даёт много коллизий.
# Сложность вычисления: O(n), где n — длина строки.

def simple_hash(s: str) -> int:
    h = 0
    for ch in s:
        h += ord(ch)
    return h

if __name__ == "__main__":
    print(simple_hash("hello"))
```

```PYTHON
# hash_table_chaining.py
"""
Хеш‑таблица методом цепочек.
Уровень: 3.
"""

from hash_functions import simple_hash


class HashTableChaining:
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]

    # Операция вставки
    # Средний случай: O(1)
    # Худший случай (все в одну корзину): O(n)
    def insert(self, key, value):
        index = simple_hash(key) % self.size
        bucket = self.table[index]

        # Проверка на обновление
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)
                return

        bucket.append((key, value))

    # Операция поиска
    # Средний случай: O(1)
    # Худший: O(n)
    def get(self, key):
        index = simple_hash(key) % self.size
        bucket = self.table[index]
        for k, v in bucket:
            if k == key:
                return v
        return None

    # Операция удаления
    # Средний случай: O(1)
    # Худший: O(n)
    def remove(self, key):
        index = simple_hash(key) % self.size
        bucket = self.table[index]
        for i, (k, v) in enumerate(bucket):
            if k == key:
                del bucket[i]
                return True
        return False


if __name__ == "__main__":
    ht = HashTableChaining(5)
    ht.insert("a", 1)
    ht.insert("b", 2)
    ht.insert("c", 3)
    print(ht.get("b"))
    ht.remove("b")
    print(ht.get("b"))
```

```PYTHON
# measure.py
"""
Базовые замеры работы хеш‑таблицы.
Уровень: 3.
"""

import time
from hash_table_chaining import HashTableChaining


def measure(n=10000):
    ht = HashTableChaining(100)

    # Замер вставки
    start = time.time()
    for i in range(n):
        ht.insert(str(i), i)
    end = time.time()
    print(f"Вставка {n} элементов: {end - start:.6f} sec")

    # Замер поиска
    start = time.time()
    for i in range(n):
        ht.get(str(i))
    end = time.time()
    print(f"Поиск {n} элементов: {end - start:.6f} sec")


if __name__ == "__main__":
    measure(5000)
```

## Ответы на контрольные вопросы

1. **Каким требованиям должна удовлетворять хорошая хеш-функция?**  
   Детерминированность, равномерное распределение, высокая скорость вычисления,  
   минимальное количество коллизий.

2. **Что такое коллизия в хеш-таблице? Опишите два основных метода разрешения коллизий.**  
   Коллизия — совпадение хешей у разных ключей.  
   Основные методы:
   - Цепочки (chaining) — в одной ячейке хранится список элементов.
   - Открытая адресация (open addressing) — при коллизии ищется другая свободная ячейка (линейное, квадратичное или двойное пробирование).

3. **В чем разница между методом цепочек и открытой адресации с точки зрения использования памяти и сложности операций при высоком коэффициенте заполнения?**  
    - Цепочки используют списки внутри таблицы, проще реализуются и устойчивы к коллизиям.
    - Открытая адресация хранит все данные в массиве, экономит память, но хуже работает при высокой загрузке (α > 0.7).

4. **Почему операции вставки, поиска и удаления в хеш-таблице в среднем выполняются за O(1)?**  
   Потому что вычисление хеша и обращение по индексу происходят за постоянное время,а при равномерном распределении коллизии редки.

5. **Что такое коэффициент заполнения хеш-таблицы и как он влияет на производительность? Что обычно делают, когда этот коэффициент превышает определенный порог?**  
   Коэффициент заполнения (α = n/m) показывает, насколько таблица заполнена. При α > 0.7 резко растёт количество коллизий, поэтому таблицу увеличивают (rehash). Оптимальное значение — до 0.7.