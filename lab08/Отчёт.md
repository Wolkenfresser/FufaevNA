# Лабораторная №8 

# Жадные алгоритмы 

**Дата:** 2025-11-26
**Семестр:** 3 курс 5 семестр
**Группа:** ПИЖ-б-о-23-2(1)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Фуфаев Никита Александрович

## Цель работы

Изучить метод проектирования алгоритмов, известный как "жадный алгоритм". Освоить принцип принятия локально оптимальных решений на каждом шаге и понять условия, при которых этот подход приводит к глобально оптимальному решению. Получить практические навыки реализации жадных алгоритмов для решения классических задач, анализа их корректности и оценки эффективности.

## Практическая часть

### Выполненные задачи

- [ ] Реализовать классические жадные алгоритмы.
- [ ] Проанализировать их корректность (доказать или объяснить, почему жадный выбор приводит к оптимальному решению).
- [ ] Провести сравнительный анализ эффективности жадного подхода и других методов (например, полного перебора для маленьких входных данных).
- [ ] Решить практические задачи с применением жадного подхода.

### Ключевые фрагменты кода

```PYTHON
# greedy_algorithms.py
"""
Два жадных алгоритма (уровень 3):
1) Interval Scheduling
2) Fractional Knapsack
Каждый алгоритм содержит комментарии со сложностью.
"""

# ---------------------------------------------------------
# 1. Выбор заявок (Interval Scheduling)
# Жадный выбор: сортировать интервалы по времени окончания
# Сложность: O(n log n)
# ---------------------------------------------------------

def interval_scheduling(intervals):
    # intervals = [(start, end), ...]
    intervals = sorted(intervals, key=lambda x: x[1])  # сортировка по окончанию
    result = []
    current_end = -float('inf')

    for start, end in intervals:
        if start >= current_end:
            result.append((start, end))
            current_end = end

    return result


# ---------------------------------------------------------
# 2. Непрерывный рюкзак (Fractional Knapsack)
# Жадный выбор: брать предметы с максимальной удельной стоимостью (value/weight)
# Сложность: O(n log n) — сортировка
# ---------------------------------------------------------

def fractional_knapsack(items, capacity):
    # items = [(value, weight), ...]
    # сортировка по value/weight
    items = sorted(items, key=lambda x: x[0] / x[1], reverse=True)

    total_value = 0
    remaining = capacity

    for value, weight in items:
        if remaining == 0:
            break
        if weight <= remaining:
            total_value += value
            remaining -= weight
        else:
            fraction = remaining / weight
            total_value += value * fraction
            remaining = 0
            break

    return total_value


if __name__ == "__main__":
    # Демонстрация
    intervals = [(1, 3), (2, 5), (4, 7), (1, 8), (5, 9)]
    print("Interval Scheduling ->", interval_scheduling(intervals))

    items = [(60, 10), (100, 20), (120, 30)]
    print("Fractional knapsack ->", fractional_knapsack(items, 50))
```

```PYTHON
# measure.py
"""
Базовые замеры выполнения жадных алгоритмов.
"""

import time
import random
from greedy_algorithms import interval_scheduling, fractional_knapsack


def measure_interval(n=10000):
    intervals = [(random.randint(0, 10000), random.randint(1, 10000)) for _ in range(n)]
    # обеспечиваем start <= end
    intervals = [(min(a, b), max(a, b)) for a, b in intervals]

    start = time.time()
    interval_scheduling(intervals)
    print(f"Interval Scheduling ({n} интервалы): {time.time() - start:.6f} sec")


def measure_knapsack(n=10000):
    items = [(random.randint(1, 100), random.randint(1, 50)) for _ in range(n)]

    start = time.time()
    fractional_knapsack(items, capacity=5000)
    print(f"Fractional Knapsack ({n} предметов): {time.time() - start:.6f} sec")


if __name__ == "__main__":
    measure_interval(5000)
    measure_knapsack(5000)
```

## Ответы на контрольные вопросы

1. **В чем заключается основная идея жадных алгоритмов?**  
   В локальном выборе максимально выгодного решения на каждом шаге.

2. **Почему стратегия выбора интервалов с минимальным временем окончания оптимальна?**  
   Потому что она оставляет максимальное количество времени для последующих интервалов (доказательство методом обмена).

3. **Пример задач, где жадный метод работает и не работает.**  
   ✔ Работает: Хаффман, Interval Scheduling, Fractional Knapsack.  
   ✘ Не работает: 0–1 Knapsack, нестандартные системы монет.

4. **Разница между дробным и дискретным рюкзаком.**  
   В дробном можно брать части предметов → жадный выбор оптимален.  
   В дискретном нельзя → жадность не работает.

5. **Оптимальность алгоритма Хаффмана.**  
   Он минимизирует суммарную стоимость кодов, всегда объединяя два наименее частотных элемента.