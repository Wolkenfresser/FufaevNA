# Лабораторная работа №9 

# Динамическое программирование

**Дата:** 2025-12-1
**Семестр:** 3 курс 5 семестр
**Группа:** ПИЖ-б-о-23-2(1)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Фуфаев Никита Александрович

## Цель работы

Изучить метод динамического программирования (ДП) как мощный инструмент для решения сложных задач путём их разбиения на перекрывающиеся подзадачи. Освоить два основных подхода к реализации ДП: нисходящий (с мемоизацией) и восходящий (с заполнением таблицы). Получить практические навыки выявления оптимальной подструктуры задач, построения таблиц ДП и анализа временной и пространственной сложности алгоритмов.

## Практическая часть

### Выполненные задачи

- [ ] Реализовать классические алгоритмы динамического программирования.
- [ ] Реализовать оба подхода (нисходящий и восходящий) для решения задач.
- [ ] Провести сравнительный анализ эффективности двух подходов.
- [ ] Проанализировать временную и пространственную сложность алгоритмов.
- [ ] Решить практические задачи с применением ДП.

### Ключевые фрагменты кода

```PYTHON
# dynamic_programming.py
"""
Динамическое программирование (базовый набор для оценки 3)
1) Фибоначчи — табличный DP
2) 0–1 Knapsack — bottom-up DP
Каждый алгоритм содержит пояснение и сложность.
"""

# ---------------------------------------------
# 1. Числа Фибоначчи — bottom-up (итеративное DP)
# Время: O(n), Память: O(n)
# ---------------------------------------------

def fib_dp(n: int) -> int:
    if n <= 1:
        return n
    dp = [0] * (n + 1)
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]


# ---------------------------------------------
# 2. 0–1 Knapsack — bottom-up DP
# Время: O(n * W), Память: O(n * W)
# items = [(value, weight), ...]
# ---------------------------------------------

def knapsack_01(items, capacity):
    n = len(items)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        value, weight = items[i - 1]
        for w in range(capacity + 1):
            if weight <= w:
                dp[i][w] = max(
                    dp[i - 1][w],  # не берём
                    dp[i - 1][w - weight] + value  # берём
                )
            else:
                dp[i][w] = dp[i - 1][w]
    return dp[n][capacity]


if __name__ == "__main__":
    print("fib_dp(10) =", fib_dp(10))
    items = [(60, 10), (100, 20), (120, 30)]
    print("knapsack =", knapsack_01(items, 50))
```

```PYTHON
# measure.py
"""
Базовые замеры для двух алгоритмов ДП.
"""

import time
from dynamic_programming import fib_dp, knapsack_01
import random


def measure_fib():
    for n in [1000, 2000, 3000]:
        start = time.time()
        fib_dp(n)
        print(f"fib_dp({n}) => {time.time() - start:.6f} sec")


def measure_knapsack():
    items = [(random.randint(10, 100), random.randint(5, 20)) for _ in range(40)]
    start = time.time()
    knapsack_01(items, capacity=200)
    print(f"0-1 knapsack => {time.time() - start:.6f} sec")


if __name__ == "__main__":
    measure_fib()
    measure_knapsack()
```

## Контрольные вопросы
1. **Какие два основных свойства задачи указывают на то, что для её решения можно применить динамическое программирование?** 
   - Оптимальная подструктура
    Оптимальное решение задачи можно построить из оптимальных решений её подзадач.
    Например: лучший выбор предметов для ёмкости W включает лучший выбор для меньшей ёмкости W − weight[i].

   - Перекрывающиеся подзадачи
    При рекурсивном разбиении одна и та же подзадача возникает многократно.
    Например: в рекурсивном вычислении Фибоначчи значения F(n−1) и F(n−2) используются десятки раз. 


2. **Разница между top-down и bottom-up?** 
   - Top-down: рекурсия + мемоизация, вычисляет только нужные подзадачи.
   - Bottom-up: итеративное заполнение таблицы, быстрее и без рекурсии.

3. **Как задача о рюкзаке 0–1 демонстрирует оптимальную подструктуру?**

- Оптимальное решение задачи для некоторой ёмкости строится из оптимальных решений подзадач для меньших ёмкостей: либо предмет не берётся, либо берётся, и тогда решение опирается на оптимальный выбор для оставшейся вместимости. Таким образом, большая задача раскладывается на несколько меньших оптимальных подзадач.

4. **Как строится таблица для LCS?**

- Строится матрица, где каждая ячейка отражает длину LCS для префиксов двух строк. Таблица заполняется последовательно: если текущие символы совпадают, значение увеличивается на единицу относительно диагонали; если нет — выбирается максимум из значений сверху или слева. В конце последняя ячейка содержит длину LCS.

5. **Как динамическое программирование уменьшает сложность вычисления Фибоначчи?**

- Вместо многократного перерасчёта одних и тех же значений сохраняются результаты промежуточных вычислений (мемоизация) либо последовательность строится снизу вверх. Это устраняет экспоненциальное дублирование вычислений и снижает сложность до линейной, а оптимизированный вариант с матрицами — до логарифмической.