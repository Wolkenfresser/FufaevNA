# Лабораторная работа №2

# Основные структуры данных. Анализ и применение

**Дата:** 2025-10-14
**Семестр:** 3 курс 5 семестр
**Группа:** ПИЖ-б-о-23-2(1)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Фуфаев Никита Александрович

## Цель работы
Изучить понятие и особенности базовых абстрактных типов данных (стек, очередь, дек,
 связный список) и их реализаций в Python. Научиться выбирать оптимальную структуру данных для
 решения конкретной задачи, основываясь на анализе теоретической и практической сложности
 операций. Получить навыки измерения производительности и применения структур данных для
 решения практических задач.

## Практическая часть

### Выполненные задачи
- [ ] Задача 1: Реализовать класс LinkedList (связный список) для демонстрации принципов его работы.
- [ ] Задача 2: Используя встроенные типы данных (list, collections.deque), проанализировать
 эффективность операций, имитирующих поведение стека, очереди и дека.
- [ ] Задача 3: Провести сравнительный анализ производительности операций для разных структур данных
 (list vs LinkedList для вставки, list vs deque для очереди).
- [ ] Задача 4: Решить 2-3 практические задачи, выбрав оптимальную структуру данных.


### Ключевые фрагменты кода

```PYTHON
# linked_list.py
"""
linked_list.py
Реализация односвязного списка (минимальный набор для оценки 3).
"""

from typing import Any, Optional


class Node:
    def __init__(self, data: Any, next: Optional['Node'] = None):
        self.data = data
        self.next = next


class LinkedList:
    def __init__(self):
        self.head: Optional[Node] = None

    def insert_at_start(self, data: Any) -> None:
        """
        Вставка в начало списка.
        Сложность: O(1)
        """
        node = Node(data, self.head)
        self.head = node

    def delete_from_start(self) -> Optional[Any]:
        """
        Удаление из начала списка и возврат данных.
        Сложность: O(1)
        """
        if self.head is None:
            return None
        data = self.head.data
        self.head = self.head.next
        return data

    def traversal(self) -> list:
        """
        Пройти по всем элементам и вернуть список значений.
        Сложность: O(n)
        """
        res = []
        cur = self.head
        while cur:
            res.append(cur.data)
            cur = cur.next
        return res


if __name__ == "__main__":
    # Небольшая демонстрация
    ll = LinkedList()
    ll.insert_at_start(1)
    ll.insert_at_start(2)
    ll.insert_at_start(3)
    print("Содержимое списка:", ll.traversal())
    print("Удалённый элемент:", ll.delete_from_start())
    print("После удаления:", ll.traversal())
```

```PYTHON
# performance_analysis.py
"""
performance_analysis.py
Простой замер времени: вставка в начало для list и для LinkedList.
"""
import timeit
from lab02.linked_list import LinkedList


SETUP_LIST = "l = []"
CODE_LIST_INSERT = "for i in range(N): l.insert(0, i)"

SETUP_LL = "from linked_list import LinkedList\nll = LinkedList()"
CODE_LL_INSERT = "for i in range(N): ll.insert_at_start(i)"


def measure(N=1000, repeats=5):
    globals_map = {'N': N}
    t_list = timeit.timeit(stmt=CODE_LIST_INSERT, setup=SETUP_LIST, number=1, globals=globals_map)
    t_ll = timeit.timeit(stmt=CODE_LL_INSERT, setup=SETUP_LL, number=1, globals=globals_map)
    print(f"N={N}")
    print(f"list.insert(0, x): {t_list:.6f} sec")
    print(f"LinkedList.insert_at_start: {t_ll:.6f} sec")


if __name__ == '__main__':
    for N in [100, 1000, 5000]:
        measure(N=N)
```

```PYTHON
# task_solutions.py
"""
task_solutions.py
Практическая задача: проверка сбалансированности скобок с помощью стека (list).
"""

BRACKETS = {
    ')': '(',
    ']': '[',
    '}': '{'
}


def is_balanced(s: str) -> bool:
    stack = []  # стек, реализованный на list
    for ch in s:
        if ch in '([{':
            stack.append(ch)  # push — O(1)
        elif ch in ')]}':
            if not stack:
                return False
            if stack.pop() != BRACKETS[ch]:  # pop — O(1)
                return False
        # игнорируем другие символы
    return not stack


if __name__ == '__main__':
    tests = [
        ("([]){}", True),
        ("([)]", False),
        ("((()))", True),
        ("", True),
        ("{[()()]}", True)
    ]
    for s, expected in tests:
        print(s, is_balanced(s), "expected=", expected)
```

## Ответы на контрольные вопросы

## 1. Отличие динамического массива (list) от связного списка по сложности операций

- **Динамический массив (`list` в Python)** хранит элементы в **непрерывной области памяти**.  
  - Вставка в начало требует **сдвига всех элементов**, поэтому имеет сложность **O(n)**.  
  - Доступ по индексу выполняется за **O(1)**, так как элемент можно найти по адресу.  

- **Связный список** хранит элементы в **узлах**, связанных ссылками.  
  - Вставка в начало — просто изменение одной ссылки, сложность **O(1)**.  
  - Доступ по индексу требует последовательного обхода, сложность **O(n)**.

---

## 2. Принцип работы стека и очереди с примерами

- **Стек (LIFO — Last In, First Out)**: последний добавленный элемент извлекается первым.  
  **Примеры использования:**
  1. Реализация механизма *undo/redo* в редакторах.
  2. Обход дерева в глубину (DFS).

- **Очередь (FIFO — First In, First Out)**: первый добавленный элемент извлекается первым.  
  **Примеры использования:**
  1. Планирование задач в операционной системе.  
  2. Обработка запросов в принтере или веб-сервере.

---

## 3. Почему `list.pop(0)` — O(n), а `deque.popleft()` — O(1)

- В `list` элементы хранятся подряд в памяти. При удалении первого элемента все остальные **сдвигаются на одну позицию**, что требует **O(n)** времени.  
- В `deque` элементы хранятся в **двухсторонней очереди**, где есть ссылки на начало и конец. Удаление первого элемента лишь изменяет ссылку, без сдвига, поэтому выполняется за **O(1)**.

---

## 4. Какая структура данных подходит для системы "отмены действий" (undo)

Наилучший выбор — **стек (LIFO)**.  
Каждое новое действие помещается на вершину стека. При выполнении "Отмены" извлекается последнее действие, которое было выполнено последним — это идеально соответствует принципу LIFO.  
Для функции *повтора (redo)* можно использовать второй стек.

---

## 5. Почему вставка в начало списка медленнее, чем в связный список

- У **списка (list)** вставка в начало требует **сдвига всех элементов вправо**, что даёт сложность **O(n)**.  
- У **связного списка** вставка в начало — это просто добавление нового узла и изменение одной ссылки (**O(1)**).  

Поэтому при вставке 1000 элементов в начало список тратит значительно больше времени, чем связный список, что и подтверждает теоретическую асимптотику.